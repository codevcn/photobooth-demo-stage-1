<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL Image Editor</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: #fff;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        text-align: center;
        margin-bottom: 30px;
        opacity: 0.9;
      }

      .canvas-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      canvas {
        display: block;
        max-width: 100%;
        height: auto;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        background: #000;
      }

      .controls {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .control-group {
        margin-bottom: 20px;
      }

      .control-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        font-size: 14px;
      }

      input[type='range'] {
        width: 100%;
        height: 8px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }

      input[type='range']::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        border: none;
      }

      .value-display {
        display: inline-block;
        float: right;
        background: rgba(255, 255, 255, 0.2);
        padding: 2px 10px;
        border-radius: 5px;
        font-size: 12px;
      }

      .filter-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-bottom: 20px;
      }

      button {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.2);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 14px;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      button.active {
        background: #fff;
        color: #667eea;
      }

      .action-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .action-buttons button {
        flex: 1;
      }

      .download-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      .reset-btn {
        background: rgba(255, 59, 48, 0.8);
      }

      input[type='file'] {
        display: none;
      }

      .upload-label {
        display: inline-block;
        padding: 12px 20px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: 600;
      }

      .upload-label:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .info {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      .info h3 {
        margin-bottom: 10px;
      }

      .info ul {
        list-style: none;
        padding-left: 0;
      }

      .info li {
        padding: 5px 0;
        padding-left: 20px;
        position: relative;
      }

      .info li:before {
        content: '‚ö°';
        position: absolute;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üé® WebGL Image Editor</h1>
      <p class="subtitle">Real-time GPU processing - T·ª©c th·ªùi & Ch·∫•t l∆∞·ª£ng cao</p>

      <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="600"></canvas>
      </div>

      <div class="controls">
        <label class="upload-label">
          üìÅ T·∫£i ·∫£nh l√™n
          <input type="file" id="imageInput" accept="image/*" />
        </label>

        <h3 style="margin: 20px 0 10px 0">Filters (Click ƒë·ªÉ √°p d·ª•ng)</h3>
        <div class="filter-buttons">
          <button class="filter-btn active" data-filter="normal">Normal</button>
          <button class="filter-btn" data-filter="grayscale">Grayscale</button>
          <button class="filter-btn" data-filter="sepia">Sepia</button>
          <button class="filter-btn" data-filter="invert">Invert</button>
          <button class="filter-btn" data-filter="blur">Blur</button>
          <button class="filter-btn" data-filter="sharpen">Sharpen</button>
          <button class="filter-btn" data-filter="edge">Edge Detect</button>
          <button class="filter-btn" data-filter="emboss">Emboss</button>
        </div>

        <div class="control-group">
          <label>
            Brightness (ƒê·ªô s√°ng)
            <span class="value-display" id="brightnessValue">0</span>
          </label>
          <input type="range" id="brightness" min="-100" max="100" value="0" step="1" />
        </div>

        <div class="control-group">
          <label>
            Contrast (ƒê·ªô t∆∞∆°ng ph·∫£n)
            <span class="value-display" id="contrastValue">1.0</span>
          </label>
          <input type="range" id="contrast" min="0" max="3" value="1" step="0.01" />
        </div>

        <div class="control-group">
          <label>
            Saturation (ƒê·ªô b√£o h√≤a)
            <span class="value-display" id="saturationValue">1.0</span>
          </label>
          <input type="range" id="saturation" min="0" max="2" value="1" step="0.01" />
        </div>

        <div class="action-buttons">
          <button class="reset-btn" id="resetBtn">üîÑ Reset All</button>
          <button class="download-btn" id="downloadBtn">‚¨áÔ∏è Download (High Quality)</button>
        </div>
      </div>

      <div class="info">
        <h3>‚ö° T·∫°i sao WebGL nhanh?</h3>
        <ul>
          <li>X·ª≠ l√Ω song song tr√™n GPU v·ªõi h√†ng trƒÉm cores</li>
          <li>M·ªçi pixel ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·ªìng th·ªùi (parallel processing)</li>
          <li>Kh√¥ng block UI thread c·ªßa JavaScript</li>
          <li>Ch·∫•t l∆∞·ª£ng cao, kh√¥ng b·ªã m·∫•t d·ªØ li·ªáu</li>
          <li>Export ngay t·ª´ GPU memory ‚Üí Canvas ‚Üí Blob</li>
        </ul>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('glCanvas')
      const gl = canvas.getContext('webgl', {
        preserveDrawingBuffer: true,
        premultipliedAlpha: false,
        antialias: true,
      })

      if (!gl) {
        alert('WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y!')
      }

      // Vertex shader (v·∫Ω h√¨nh ch·ªØ nh·∫≠t)
      const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texCoord = a_texCoord;
            }
        `

      // Fragment shader (x·ª≠ l√Ω m√†u s·∫Øc t·ª´ng pixel)
      const fragmentShaderSource = `
            precision mediump float;
            
            uniform sampler2D u_image;
            uniform float u_brightness;
            uniform float u_contrast;
            uniform float u_saturation;
            uniform int u_filter;
            uniform vec2 u_textureSize;
            
            varying vec2 v_texCoord;
            
            vec3 applyConvolution(mat3 kernel) {
                vec2 onePixel = vec2(1.0) / u_textureSize;
                vec3 colorSum = vec3(0.0);
                
                for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        vec2 offset = vec2(float(j-1), float(i-1)) * onePixel;
                        vec3 color = texture2D(u_image, v_texCoord + offset).rgb;
                        colorSum += color * kernel[i][j];
                    }
                }
                
                return colorSum;
            }
            
            void main() {
                vec4 color = texture2D(u_image, v_texCoord);
                vec3 rgb = color.rgb;
                
                // √Åp d·ª•ng filter
                if (u_filter == 1) { // Grayscale
                    float gray = dot(rgb, vec3(0.299, 0.587, 0.114));
                    rgb = vec3(gray);
                } else if (u_filter == 2) { // Sepia
                    rgb = vec3(
                        dot(rgb, vec3(0.393, 0.769, 0.189)),
                        dot(rgb, vec3(0.349, 0.686, 0.168)),
                        dot(rgb, vec3(0.272, 0.534, 0.131))
                    );
                } else if (u_filter == 3) { // Invert
                    rgb = 1.0 - rgb;
                } else if (u_filter == 4) { // Blur
                    mat3 kernel = mat3(
                        1.0/16.0, 2.0/16.0, 1.0/16.0,
                        2.0/16.0, 4.0/16.0, 2.0/16.0,
                        1.0/16.0, 2.0/16.0, 1.0/16.0
                    );
                    rgb = applyConvolution(kernel);
                } else if (u_filter == 5) { // Sharpen
                    mat3 kernel = mat3(
                        0.0, -1.0, 0.0,
                        -1.0, 5.0, -1.0,
                        0.0, -1.0, 0.0
                    );
                    rgb = applyConvolution(kernel);
                } else if (u_filter == 6) { // Edge Detect
                    mat3 kernel = mat3(
                        -1.0, -1.0, -1.0,
                        -1.0, 8.0, -1.0,
                        -1.0, -1.0, -1.0
                    );
                    rgb = applyConvolution(kernel);
                } else if (u_filter == 7) { // Emboss
                    mat3 kernel = mat3(
                        -2.0, -1.0, 0.0,
                        -1.0, 1.0, 1.0,
                        0.0, 1.0, 2.0
                    );
                    rgb = applyConvolution(kernel);
                }
                
                // Brightness
                rgb += u_brightness / 255.0;
                
                // Contrast
                rgb = (rgb - 0.5) * u_contrast + 0.5;
                
                // Saturation
                float gray = dot(rgb, vec3(0.299, 0.587, 0.114));
                rgb = mix(vec3(gray), rgb, u_saturation);
                
                gl_FragColor = vec4(clamp(rgb, 0.0, 1.0), color.a);
            }
        `

      function createShader(gl, type, source) {
        const shader = gl.createShader(type)
        gl.shaderSource(shader, source)
        gl.compileShader(shader)

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader))
          gl.deleteShader(shader)
          return null
        }
        return shader
      }

      function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram()
        gl.attachShader(program, vertexShader)
        gl.attachShader(program, fragmentShader)
        gl.linkProgram(program)

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link error:', gl.getProgramInfoLog(program))
          gl.deleteProgram(program)
          return null
        }
        return program
      }

      // Compile shaders
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource)
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)
      const program = createProgram(gl, vertexShader, fragmentShader)

      // Get attribute/uniform locations
      const positionLocation = gl.getAttribLocation(program, 'a_position')
      const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord')
      const imageLocation = gl.getUniformLocation(program, 'u_image')
      const brightnessLocation = gl.getUniformLocation(program, 'u_brightness')
      const contrastLocation = gl.getUniformLocation(program, 'u_contrast')
      const saturationLocation = gl.getUniformLocation(program, 'u_saturation')
      const filterLocation = gl.getUniformLocation(program, 'u_filter')
      const textureSizeLocation = gl.getUniformLocation(program, 'u_textureSize')

      // Create buffers
      const positionBuffer = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        gl.STATIC_DRAW
      )

      const texCoordBuffer = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer)
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]),
        gl.STATIC_DRAW
      )

      // Create texture
      const texture = gl.createTexture()
      gl.bindTexture(gl.TEXTURE_2D, texture)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)

      let currentImage = null
      let currentFilter = 0
      let brightness = 0
      let contrast = 1
      let saturation = 1

      // Load default image
      const defaultImage = new Image()
      defaultImage.crossOrigin = 'anonymous'
      defaultImage.src =
        'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojNzY0YmEyO3N0b3Atb3BhY2l0eToxIiAvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iNjAwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+PHRleHQgeD0iNDAwIiB5PSIyNTAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0OCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtd2VpZ2h0PSJib2xkIj5XZWJHTCBJbWFnZSBFZGl0b3I8L3RleHQ+PHRleHQgeD0iNDAwIiB5PSIzMjAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkNsaWNrICJU4bqjaSDhuqNuaCBsw6puIiDEkeG7gyBi4bqvdCDEkeG6p3U8L3RleHQ+PHRleHQgeD0iNDAwIiB5PSIzNjAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyMCIgZmlsbD0icmdiYSgyNTUsMjU1LDI1NSwwLjgpIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5HUFUgUHJvY2Vzc2luZyAtIFRo4buwIGZpbHRlciwgYWRqdXN0IHHVQW5nIMSR4buTPC90ZXh0Pjwvc3ZnPg=='
      defaultImage.onload = () => {
        loadImage(defaultImage)
      }

      function loadImage(img) {
        currentImage = img

        // Resize canvas
        canvas.width = img.width
        canvas.height = img.height

        // Upload texture
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)

        render()
      }

      function render() {
        gl.viewport(0, 0, canvas.width, canvas.height)
        gl.clearColor(0, 0, 0, 0)
        gl.clear(gl.COLOR_BUFFER_BIT)

        gl.useProgram(program)

        // Position
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
        gl.enableVertexAttribArray(positionLocation)
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0)

        // TexCoord
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer)
        gl.enableVertexAttribArray(texCoordLocation)
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0)

        // Set uniforms
        gl.uniform1i(imageLocation, 0)
        gl.uniform1f(brightnessLocation, brightness)
        gl.uniform1f(contrastLocation, contrast)
        gl.uniform1f(saturationLocation, saturation)
        gl.uniform1i(filterLocation, currentFilter)
        gl.uniform2f(textureSizeLocation, canvas.width, canvas.height)

        gl.drawArrays(gl.TRIANGLES, 0, 6)
      }

      // Event handlers
      document.getElementById('imageInput').addEventListener('change', (e) => {
        const file = e.target.files[0]
        if (file) {
          const reader = new FileReader()
          reader.onload = (event) => {
            const img = new Image()
            img.onload = () => loadImage(img)
            img.src = event.target.result
          }
          reader.readAsDataURL(file)
        }
      })

      document.querySelectorAll('.filter-btn').forEach((btn) => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
          btn.classList.add('active')

          const filters = {
            normal: 0,
            grayscale: 1,
            sepia: 2,
            invert: 3,
            blur: 4,
            sharpen: 5,
            edge: 6,
            emboss: 7,
          }

          currentFilter = filters[btn.dataset.filter]
          render()
        })
      })

      document.getElementById('brightness').addEventListener('input', (e) => {
        brightness = parseFloat(e.target.value)
        document.getElementById('brightnessValue').textContent = brightness
        render()
      })

      document.getElementById('contrast').addEventListener('input', (e) => {
        contrast = parseFloat(e.target.value)
        document.getElementById('contrastValue').textContent = contrast.toFixed(2)
        render()
      })

      document.getElementById('saturation').addEventListener('input', (e) => {
        saturation = parseFloat(e.target.value)
        document.getElementById('saturationValue').textContent = saturation.toFixed(2)
        render()
      })

      document.getElementById('resetBtn').addEventListener('click', () => {
        currentFilter = 0
        brightness = 0
        contrast = 1
        saturation = 1

        document.getElementById('brightness').value = 0
        document.getElementById('contrast').value = 1
        document.getElementById('saturation').value = 1
        document.getElementById('brightnessValue').textContent = 0
        document.getElementById('contrastValue').textContent = '1.0'
        document.getElementById('saturationValue').textContent = '1.0'

        document.querySelectorAll('.filter-btn').forEach((b) => b.classList.remove('active'))
        document.querySelector('[data-filter="normal"]').classList.add('active')

        render()
      })

      document.getElementById('downloadBtn').addEventListener('click', () => {
        canvas.toBlob(
          (blob) => {
            const url = URL.createObjectURL(blob)
            const a = document.createElement('a')
            a.href = url
            a.download = 'webgl-edited-image.png'
            a.click()
            URL.revokeObjectURL(url)

            alert('‚úÖ ƒê√£ t·∫£i xu·ªëng ·∫£nh ch·∫•t l∆∞·ª£ng cao!')
          },
          'image/png',
          1.0
        )
      })
    </script>
  </body>
</html>
